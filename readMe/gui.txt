Action: 요소에 일어나는 이벤트 처리(클릭, 글자바뀜, 포커스 발생/사라짐 등)
	Action처리를 위해서 ActionListener 인터페이스를 상속받아서 구현

KeyEvent: 키보드에서 일어나는 이벤트(키 누름/올라옴 등)
KeyEvent KeyListener 인터페이스를 구현



MouseEvent:  마우스에서 일어나는 이벤트 (움직임, 클릭, 꾹 누름/뗌 등)

GUI 채팅
1. 채팅 클라이언트 UI 그리기
1-1. 채팅 내용을 볼 수 있는 TextArea
1-2. 채팅을 입력받는 TextField
1-3. 전송 버튼

2. TCP 채팅을 위한 준비사항
2-1. 생성자에서 소켓을 연결해주기, 서버 ip가 필요
	소켓을 유지하면서 데이터를 주고 받아야 하기 때문에 소켓을 멤버 변수로 둔다.
2-2. 연결은? 접속 버튼을 누르면 접속: 접속 버튼 ActionListener 작성
	textField에 있는 ip를 가져와서 Socket 객체를 만들면 된다.

3. 채팅 메시지 전송하기
3-1. 전송 버튼이 눌러지면 채팅 textField에 있는 내용을 서버로 보낸다.

프로토콜(통신규약)
복수의 컴퓨터 사이나 중앙 컴퓨터와 단말기 사이에서 데이터 통신을 원활하게 하기 위해 필요한 통신 규약.
신호 송신의 순서, 데이터의 표현법 등을 정의한 통신 규약이다.

login##zkfzkfktm/123
chat##안녕

guiChat: 클라이언트는 서버로 채팅 메시지만 전달함.
		서버는 메시지 구분없이 받자마자 바로 전달하는 역할
		 
guiChat2: 클라이언트가 서버로 보내는 메시지의 종류를 다양하게 만들어보자
		서버가 어떤 메시지를 받았는지 구분. 메시지의 종류에 따라 다른 작업을 하게 된다.
		메시지를 구분하기 위해서는 약속(혹은 규칙)이 필요하다.
		그리고 이 약속(규칙)을 프로토콜이라고 부름.
		
		ex) 닉네임 변경: 01##변경할 닉네임
			채팅 메시지: 02##채팅 메시지
			
		닉네임을 서버가 가지고 있도록한다.
		
응용
 Protocol 객체를 이용해서 데이터 전달하기.
메시지의 타입/ 메시지의 내용
예) 01##홍길동
 
 ObjectStream을 이용해서 메시지를 전달한다.
방법1: Protocol 객체가 String: type, Map<String,Object> data를 가진다.
방법2: Protocol 객체가 Map<String,Object> data를 가진다.
	(요소로써 메시지 타입과 데이터를 가진다) 
	
guiChat3에서는 방법1을 사용한다.

		