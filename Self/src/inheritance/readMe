static 변수(정적변수),
static 메서드(정적메서드)

객체 : new 생성자()를 통해 생성 됨
Student s1; : Student 타입의 객체를 참조할 수 있는 s라는 참조변수
(name, grade)
Student s1 = new Student();
s1.setName("홍길동");
Student s2 = new Student(); : 객체가 만들어지고 s를 통해 참조할 수 있음
s2.setName("이순신");

인스턴스
객체로 접근할 수 있게 만드는 모든 변수들, 위의 s1, s1.name 등 이 인스턴스 (s를 객체라도 불러도 무방하긴 함)

클래스

변수
1. 인스턴스변수 : 각 객체가 가지고 있는 변수
2. static변수 : 클래스 당 하나, 모든 객체가 공유하는 변수
			모든 객체가 동일한 값을 가지는 변수가 존재할 때,
			객체마다 해당 변수를 생성하여 주면 동일한 값을 가지는 변수가 계속 생성되는 낭비가 발생한다.
			그렇기 때문에 모든 객체가 똑같은 데이터를 가진 변수를 사용할 때 는 static변수를 이용한다.

메서드
객체의 상태와 상관없이 항상 동일한 동작을 할 때는 static으로 선언

static 변수와 static method는
static way(클래스 이름으로 접근)로 사용한다.
객체가 없어도 사용할 수 있기 때문에 객체로 접근하는 방식은 옳지못하다.


Inheritance(상속)
코드의 재사용을 위한 기법


접근제한자(public/private/protected/(default : 기본상태, 명칭이 여러개인듯?))
public : 외부 클래스에서 접근허용
private : 외부 클래스에서 접근불가
(default) : 접근 제한자가 없을 때, 같은 패키지 안의 외부 클래스에서만 접근허용
protected : (default)와 동일한 역할
			단, 상속관계(다른 패키지의 클래스라도 같은 패키지 안의 외부 클래스를 상속받은 경우)라면 접근 가능.
			(디폴트와 다른 점!)
			
부모클래스 : 상속을 해주는 클래스 (super class)
자식클래스 : 상속을 받는 클래스 (sub class)

자식클래스는 부모클래스에 선언된 변수나 메서드를 포함하고 있다.
자식클래스의 객체를 만들때는 부모클래스의 객체도 함께 생성이 된다.
-자식클래스의 생성자가 호출되면,
생성자의 맨 윗줄에서는 부모클래스의 생성자가 호출되어야한다.
만약 호출하지 않으면 부모클래스의 기본생성자가 생력되어 있는 것과 같다.

super
자식 클래스 내에서 부모클래스의 객체를 지칭하는 키워드

자식클래스의 객체는 부모클래스의 객체도 포함하고 있다.
그렇기 때문에 부모 객체처럼 취급할 수 있다. (is-a 관계에 있을 때 객체는 참조가능하다.)
(자식클래스의 객체는 부모클래스의 참조 변수에 참조할 수 있다.)

스포츠카는 자동차이다.
SportsCar is a Car ? 참
예) Car c1 = new SportsCar();		O
		c1 : 부모클래스에 자식클래스가 참조되어 있더라도
			부모클래스의 참조변수를 통해서는 자식 클래스의 기능, 변수를 사용할 수 없다.
			굳이 사용하고 싶다면 형변환을 통해서 사용해야 한다.
			((SportsCar)c1).turboOn(); 이렇게 사용하거나
			SportsCar c2 = (SportsCar)c1;
			c2.turboOn(); 				이렇게 사용할 수 있다
			
Car is a SportsCar ? 거짓
	SportsCar myCar = new Car();	X

instanceof : 인스턴스가 어느 클래스의 객체인지 확인하는 연산자
(특히 부모클래스의 참조변수에 참조되어있는 객체가 어떤 자식클래스의 객체인지 확인할 때 사용)


메서드 오버로딩 : 중복 메서드
메서드 오버라이딩 : 메소드 재정의 

메서드 오버로딩(중복메서드) vs 메서드 오버라이딩(메서드 재정의)




